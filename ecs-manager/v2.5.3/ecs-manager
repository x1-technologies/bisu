#!/bin/bash

######################################################## BISU Importer Start #########################################################
## Have a fresh installation for BISU with copy and paste the command below
## sudo curl -sL https://raw.githubusercontent.com/x-1-repo/bisu/master/bisu/bisu.latest.bash -o "/usr/local/sbin/bisu.bash"
## Set the required version of BISU
export THIS_REQUIRED_BISU_VERSION="^4.9.0"
export BISU_PRODUCTION="/usr/local/sbin/bisu.bash"
export BISU_TESTING="$HOME/Documents/Projects/bisu/bisu/bisu.latest.bash"
## Decide the reference BISU file by enviroment of production or testing
export BISU_ENV="production"
## Import BISU file
[ "$BISU_ENV" == "production" ] && source "$BISU_PRODUCTION" || [ "$BISU_ENV" == "testing" ] && source "$BISU_TESTING" || {
    echo -e "Error: Unable to load BISU" >&2
    exit 1
}
export CURRENT_COMMAND="${BASH_SOURCE[0]} $@"
## <required-external-commands>
export REQUIRED_EXTERNAL_COMMANDS=('vi')
## </required-external-commands>
bisu_main "$@"
######################################################## BISU Importer End ###########################################################

# An agile tool to easily manage over 1,000 ECS instances
# As an extra method for manually operating hosts if needed
# Or personal hosts easy handling

# Set the expected version of the parent file
export ECS_MANAGER_VERSION="2.5.3"
# Set the ecs hosts configs directory path
export HOSTS_INFO_DIR="$HOME/.local/ecs-manager/ecs-instances"
# The below to set the default values for the environment
export HOST_NAME=""
export USE_PROXY=false
export USE_MOSH=false
export USERNAME="root"
export HOST_ADDR=""
export HOST_PORT="22"
export PROXY_ADDR="127.0.0.1"
export PROXY_PORT="8080"
export MOSH_PORTS="60000:61000"
# If true, the script will prefer the PEM file for SSH connection
# If you prefer to use a password, you can set it as false
export PREFER_PEM=true
# When PREFER_PEM is true, the PEM_FILE variable should be set as required
export PEM_FILE=""
# Specify which folders to search for PEM files
export PEM_FILE_DIRS=("$HOME/.ssh" ".")
# Cache for hostname modification
export HOSTNAME_BACKUP_FILE="/etc/hostname.backup.default"
# For debug
export DEBUG_MODE=false

# Universal function to generate proxy command
generate_proxy_param() {
    local use_proxy=$(trim "$USE_PROXY")
    local proxy_ip_addr=$(trim "$PROXY_ADDR")
    local proxy_port=$(trim "$PROXY_PORT")

    if [[ "$use_proxy" == "true" ]] && is_valid_ip "$proxy_ip_addr" && is_valid_port "$proxy_port"; then
        echo "-o ProxyCommand='nc -x $proxy_ip_addr:$proxy_port %h %p'"
    else
        echo ""
    fi
}

# Set extra PEM file directories
set_pem_file_dir() {
    local pem_file_dir=$(trim "$1")
    if ! is_dir "$pem_file_dir"; then
        error_exit "PEM file directory [$pem_file_dir] does not exist."
    fi
    array_unique_push "PEM_FILE_DIRS" "$pem_file_dir"
}

# Get host configuration from the configuration file
exact_host_config() {
    local host_name=$(trim "$1")
    local host_config_file="$HOSTS_INFO_DIR/$host_name.yml"

    if ! is_file "$host_config_file"; then
        error_exit "The host [$host_name] config file was not found."
    fi

    yaml_to_array "$(cat "$host_config_file")"
    log_message "Using $host_config_file"

    return 0
}

# Get host information from the configuration file
set_host_info() {
    local host_name=$(trim "$1")
    if [ -z "$host_name" ]; then
        error_exit "Host name is required."
    fi

    exact_host_config "$host_name"
    HOST_NAME="$host_name"

    local use_proxy=$(arr_get_val "USE_PROXY") && USE_PROXY="$use_proxy"
    local use_mosh=$(arr_get_val "USE_MOSH") && USE_MOSH="$use_mosh"
    local username=$(arr_get_val "USERNAME") && USERNAME="$username"
    local host_addr=$(arr_get_val "HOST_ADDR") && HOST_ADDR="$host_addr"
    local host_port=$(arr_get_val "HOST_PORT") && HOST_PORT="$host_port"
    local proxy_addr=$(arr_get_val "PROXY_ADDR") && PROXY_ADDR="$proxy_addr"
    local proxy_port=$(arr_get_val "PROXY_PORT") && PROXY_PORT="$proxy_port"
    local mosh_ports=$(arr_get_val "MOSH_PORTS") && MOSH_PORTS="$mosh_ports"
    local prefer_pem=$(arr_get_val "PREFER_PEM") && PREFER_PEM="$prefer_pem"
    local pem_file=$(arr_get_val "PEM_FILE") && PEM_FILE=$(eval echo "$pem_file")
    PEM_FILE=$(get_pem_file "$PEM_FILE")

    # Validate inputs
    if ! is_valid_ip "$HOST_ADDR"; then
        error_exit "Invalid IP address for host."
    fi

    if ! is_valid_port "$HOST_PORT"; then
        error_exit "Invalid port for host."
    fi

    if [[ -z "$USERNAME" || -z "$HOST_NAME" ]]; then
        error_exit "Username and hostname are required."
    fi

    if [[ "$PREFER_PEM" == "true" ]] && ! is_file "$PEM_FILE"; then
        error_exit "PEM file is required (currently specified as: \"$PEM_FILE\")."
    fi
}

# Prepare ssh command
prep_ssh_command() {
    local set_account=$(trim "${1:-true}")
    local use_proxy=$(trim "${2:-auto}")

    if [[ "$use_proxy" == "auto" ]]; then
        use_proxy="$USE_PROXY"
    fi

    # If MOSH is not used, connect via SSH
    ssh_command="ssh -p$HOST_PORT"

    if [[ "$set_account" == "true" ]]; then
        ssh_command="$ssh_command $USERNAME@$HOST_ADDR"
    fi

    # Apply PEM file if preferred
    if [ "$PREFER_PEM" == "true" ]; then
        log_message "Connecting to [$HOST_NAME] via SSH with PEM..."
        ssh_command="$ssh_command -i '$PEM_FILE'"
    else
        log_message "Connecting to [$HOST_NAME] via SSH..."
    fi

    if [[ "$use_proxy" == "true" ]]; then
        local proxy_command=$(generate_proxy_param)
        ssh_command="$ssh_command $proxy_command"
    fi

    echo "$ssh_command"
}

# Get the PEM file path
get_pem_file() {
    local pem_file="$PEM_FILE"

    if [[ -z "$pem_file" ]]; then
        error_exit "Pem File Not Exists"
    fi

    if string_starts_with "$pem_file" "/" && is_file "$pem_file"; then
        echo "$pem_file"
        return
    fi

    local pem_file_dirs=("${PEM_FILE_DIRS[@]}")
    for pem_file_dir in "${pem_file_dirs[@]}"; do
        pem_file_dir=$(trim "$pem_file_dir")
        if [ -z "$pem_file_dir" ]; then
            continue
        fi

        if string_ends_with "$pem_file_dir" "/"; then
            pem_file_dir=$(trim_suffix "$pem_file_dir" "/")
        fi

        if [[ "$pem_file_dir" == "." ]]; then
            pem_file_dir="$(dirname "$CURRENT_FILE_PATH")/$HOSTS_INFO_DIR"
        fi

        if is_file "$pem_file_dir/$pem_file"; then
            echo "$pem_file_dir/$pem_file"
            return
        fi
    done
    echo "$pem_file_dir/$pem_file"
}

# Prepare command for the remote via ssh protocol
ssh_remote_command() {
    local command=$(trim "$1")
    local conn_str=$(prep_ssh_command)
    local ssh_command="$conn_str $command"
    echo "$ssh_command"
}

# Execute command from the remote via ssh protocol
remote_exec_command() {
    local command=$(trim "$1")
    local ssh_command=$(ssh_remote_command "$command")
    exec_command "$ssh_command"
}

# Unified function for SSH and MOSH command execution
ssh_handle() {
    local operation=$(trim "$1")
    operation="${operation:-connect}"

    if [[ "$operation" != "connect" && "$operation" != "set-hostname" && "$operation" != "rsync" && "$operation" != "remote-command" ]]; then
        error_exit "Invalid operation."
    fi

    if [[ "$operation" == "set-hostname" && "$HOST_NAME" == *" "* ]]; then
        error_exit "Hostname can not have spaces."
    fi

    # Define necessary variables
    local ssh_command=""
    local conn_str="$USERNAME@$HOST_NAME"
    set_title "$conn_str"

    # Check if MOSH is to be used
    if [[ "$operation" == "connect" && "$USE_MOSH" = "true" ]]; then
        local params="mosh-server new -s -p $MOSH_PORTS -l LANG=en_US.UTF-8"

        # Apply PEM file if preferred
        if [ "$PREFER_PEM" == "true" ]; then
            log_message "Connecting via MOSH with PEM..."
            params="-i '$PEM_FILE' $params"
        else
            log_message "Connecting via MOSH..."
        fi

        # Construct SSH command for MOSH connection
        ssh_command="ssh -p$HOST_PORT $(generate_proxy_param) $USERNAME@$HOST_ADDR $params"
        # Execute the SSH command
        response="$(eval "$ssh_command")"

        if [ $? -ne 0 ]; then
            error_exit "Failed to execute SSH command to retrieve MOSH details."
        fi

        # Extract MOSH connection details
        mosh_key=$(echo "$response" | awk '/MOSH CONNECT/{print $4}')
        mosh_server_port=$(echo "$response" | awk '/MOSH CONNECT/{print $3}')

        if [ -z "$mosh_key" ] || [ -z "$mosh_server_port" ]; then
            error_exit "Failed to retrieve MOSH connection details."
        fi

        # Export MOSH key and address
        export MOSH_KEY="$mosh_key" &&
            mosh_server_addr="$HOST_ADDR" &&

            # Run MOSH client
            mosh-client "$mosh_server_addr" "$mosh_server_port"

        exec_command "$ssh_command"
    else
        # Set hostname
        if [[ "$operation" == "set-hostname" ]]; then
            local remote_set_hostname="test -f /etc/hostname.backup.default || cp /etc/hostname /etc/hostname.backup.default && hostnamectl set-hostname $HOST_NAME"
            log_message "Setting the hostname..."
            remote_exec_command "$remote_set_hostname"
        elif [[ "$operation" == "connect" ]]; then
            remote_exec_command
        elif [[ "$operation" == "rsync" ]]; then
            log_message "Starting rsync..."
            local dest1=$(trim "$2")
            local dest2=$(trim "$3")

            # Validate input parameters
            if [[ -z "$dest1" || -z "$dest2" ]]; then
                error_exit "Both destination parameters (dest1 and dest2) are required."
            fi

            # Validate format: "local:/path" or "remote:/path"
            local valid_regex="^(.+):(.+)$"
            if [[ ! "$dest1" =~ $valid_regex ]]; then
                error_exit "Invalid format for dest1."
            fi
            if [[ ! "$dest2" =~ $valid_regex ]]; then
                error_exit "Invalid format for dest2."
            fi

            # Extract actual paths
            local dest1_type="${dest1%%:*}"
            local dest1_path="${dest1#*:}"
            local dest2_type="${dest2%%:*}"
            local dest2_path="${dest2#*:}"

            # Build rsync arguments
            local rsync_source
            local rsync_dest

            if [[ "$dest1_type" == "local" && "$dest2_type" != "local" ]]; then
                set_host_info "$dest2_type"
                dest1_path=$(file_real_path "$dest1_path" "true")
                if [[ -z "$dest1_path" ]]; then
                    error_exit "Invalid path of dest1."
                fi
                rsync_source="$dest1_path"
                rsync_dest="$USERNAME@$HOST_ADDR:$dest2_path"
                ssh_command=$(prep_ssh_command "false")
                ssh_command="rsync -e \"$ssh_command\" -avpgolrzP \"$rsync_source\" \"$rsync_dest\""
                exec_command "$ssh_command"
            elif [[ "$dest1_type" != "local" && "$dest2_type" == "local" ]]; then
                set_host_info "$dest1_type"
                dest2_path=$(file_real_path "$dest2_path")
                if [[ -z "$dest2_path" ]]; then
                    error_exit "Invalid path of dest2."
                fi
                rsync_source="$USERNAME@$HOST_ADDR:$dest1_path"
                rsync_dest="$dest2_path"
                ssh_command=$(prep_ssh_command "false")
                ssh_command="rsync -e \"$ssh_command\" -avpgolrzP \"$rsync_source\" \"$rsync_dest\""
                exec_command "$ssh_command"
            else
                error_exit "Invalid destination(s), please check the correcness of the location tag(s)."
            fi
        elif [[ "$operation" == "remote-command" ]]; then
            local remote_command=$(trim "$3")
            if [[ -z "$remote_command" ]]; then
                error_exit "Please input a command for the remote running."
            fi
            remote_exec_command "$remote_command"
        else
            usage
        fi

        log_message "Done."
    fi
}

# Function to list hosts
list_hosts() {
    local sub_folder parent_dir host_config_dir

    # Validate and process input arguments
    sub_folder=$(trim "$1")
    parent_dir="$HOSTS_INFO_DIR"

    if [ -n "$sub_folder" ]; then
        host_config_dir="$HOSTS_INFO_DIR/$sub_folder"
    else
        host_config_dir="$HOSTS_INFO_DIR"
    fi

    if [ -z "$parent_dir" ]; then
        error_exit "Parent directory must be specified."
        return 1
    fi

    # Ensure parent directory is absolute
    if [ "${parent_dir:0:1}" != "/" ]; then
        parent_dir="$(pwd)/$parent_dir"
    fi

    # Validate that the host config directory exists
    if [ ! -e "$host_config_dir" ] && [ ! -f "$host_config_dir.yml" ]; then
        error_exit "There is no specified host."
        return 1
    fi

    # Function to compute relative path
    relative_path() {
        local target="$1"
        local base="$2"
        local path=$(echo "$target" | awk -v base="$base" '{print substr($0, length(base) + 2)}')
        echo $path
    }

    # Display the current directory at the top
    current_dir=$(relative_path "$host_config_dir" "$parent_dir")
    if [[ -n "$current_dir" ]]; then
        echo " * [$current_dir]"
    fi

    # List subdirectories with [folder] prefix
    find "$host_config_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | while read -r dir; do
        sub_dir=$(relative_path "$dir" "$parent_dir")
        echo " - [$sub_dir]"
    done

    # List files without extensions in the parent directory
    find "$host_config_dir" -mindepth 1 -maxdepth 1 -type f 2>/dev/null | while read -r file; do
        sub_dir=$(relative_path $(dirname "$file") "$parent_dir")
        file_name=$(basename "$file")
        file_name=$(echo "$file_name" | awk -F. '{OFS="."; NF--; print $0}')
        if [[ -n "$sub_dir" ]]; then
            filename="$sub_dir/$file_name"
        else
            filename="$file_name"
        fi
        echo " - $filename"
    done
}

# shortcut for creation
create() {
    local host_path=$(trim "$1")
    local host_config_dir="$HOSTS_INFO_DIR"

    if [ -z "$host_path" ]; then
        error_exit "There is no specified host."
    fi

    local host_config_path="$host_config_dir/$host_path"
    host_config_path=$(file_real_path "$host_config_path")

    if [ -z "$host_config_path" ]; then
        error_exit "There is no specified host."
    fi

    host_config_path="$host_config_path.yml"
    if string_ends_with "$host_config_path" ".yml.yml"; then
        host_config_path=$(substr "$host_config_path" 0 -4)
    fi

    if is_file "$host_config_path"; then
        error_exit "Specified host already exists."
    fi

    host_config_dir=$(dirname "$host_config_path")
    mkdir_p "$host_config_dir" || {
        error_exit "Failed to mkdir: \"$host_config_dir\""
    }

    local tmpfile="$(mktemp)" || {
        error_exit "Failed to create temp file."
    }
    array_unique_push "EXIT_WITH_COMMANDS" "rm -f \"$tmpfile\""

    cat >"$tmpfile" <<EOF
USE_PROXY: false
USE_MOSH: false
USERNAME: "root"
HOST_ADDR: ""
HOST_PORT: "22"
PROXY_ADDR: "127.0.0.1"
PROXY_PORT: "8080"
MOSH_PORTS: "60000:61000"
PREFER_PEM: false
PEM_FILE: ""
EOF

    vi "$tmpfile"
    local vi_status=$?
    if [[ "$vi_status" == 0 ]] && [ -s "$tmpfile" ]; then
        move_file "$tmpfile" "$host_config_path" "false" && {
            log_message "Host config file has been saved as: $host_config_path"
        }
    fi
}

#shortcut for vi
edit() {
    local host_path=$(trim "$1")
    local host_config_dir="$HOSTS_INFO_DIR"

    if [ -z "$host_path" ]; then
        error_exit "There is no specified host."
    fi

    local host_config_path="$host_config_dir/$host_path"
    host_config_path=$(file_real_path "$host_config_path")

    if [ -z "$host_config_path" ]; then
        error_exit "There is no specified host."
    fi

    host_config_path="$host_config_path.yml"
    if string_ends_with "$host_config_path" ".yml.yml"; then
        host_config_path=$(substr "$host_config_path" 0 -4)
    fi

    if ! is_file "$host_config_path"; then
        error_exit "There is no specified host."
    fi

    exec_command "vi \"$host_config_path\""
}

#shortcut for remove
remove() {
    local param1=$(trim "$1")
    local param2=$(trim "$2")

    if [[ "$param1" == "-f" ]] || [[ "$param1" == "--force" ]] && [ -n "$param2" ]; then
        local force="$param1"
        local host_path="$param2"
    else
        local host_path="$param1"
        local force="$param2"
    fi

    local host_config_dir="$HOSTS_INFO_DIR"
    local command=""
    local is_dir="false"

    if [ -z "$host_path" ]; then
        error_exit "There is no specified host."
    fi

    local host_config_path="$host_config_dir/$host_path"
    host_config_path=$(file_real_path "$host_config_path")

    if [ -z "$host_config_path" ]; then
        error_exit "There is no specified host."
    fi

    if [ "$force" == "-f" ] || [ "$force" == "--force" ]; then
        force="true"
    else
        force="false"
    fi

    if [ -d "$host_config_path" ]; then
        if [[ $(trim $(ls "$host_config_path")) != "" ]] && [ "$force" == "false" ]; then
            error_exit "The folder is not empty, please use -f if you want to forcefully remove it."
        fi
        is_dir="true"
    else
        host_config_path="$host_config_path.yml"
    fi

    if string_ends_with "$host_config_path" ".yml.yml"; then
        host_config_path=$(substr "$host_config_path" 0 -4)
    fi

    if ! file_exists "$host_config_path"; then
        error_exit "There is no specified host."
    fi

    if [[ "$is_dir" == "true" ]]; then
        command="rm -r \"$host_config_path\""
    else
        command="rm \"$host_config_path\""
    fi

    if confirm "Please act this carefully, recheck and press 'y' or 'n' to continue." "n"; then
        exec_command "$command"
    else
        error_exit "Aborted."
    fi
}

# ED25519 key generation
gen_ed25519_key() {
    local key_path=$(trim "$1")
    local comment=$(trim "$2")
    comment=${comment:-"$(whoami)@$(hostname)"}
    local strength=$(trim "$3")
    strength=${strength:-"high"}
    local default_filename="id_ed25519"
    local key_dir=""

    if ! command_exists "ssh-keygen"; then
        error_exit "ssh-keygen command not found."
    fi

    get_file_info "$key_path"
    local filename=$(arr_get_val "FILE_NAME")
    local file_path=$(arr_get_val "FILE_PATH")
    local file_ext=$(arr_get_val "FILE_EXT")
    local file_dir=$(arr_get_val "FILE_DIR")
    local file_exists=$(arr_get_val "FILE_EXISTS")
    local file_is_dir=$(arr_get_val "FILE_IS_DIR")
    local file_is_file=$(arr_get_val "FILE_IS_FILE")
    local file_has_ext=$(arr_get_val "FILE_HAS_EXT")

    if [ -z "$filename" ]; then
        filename="$default_filename"
    fi

    key_path="$file_path"
    key_dir="$file_dir"
    mkdir_p "$key_dir"

    # Map strength levels to bcrypt-KDF key length
    local key_length=256
    case "$strength" in
    low) key_length=64 ;;
    moderate) key_length=128 ;;
    high) key_length=256 ;;
    extreme) key_length=512 ;;
    *)
        error_exit "Invalid encryption strength: $strength"
        ;;
    esac

    local pem="$key_dir/$filename"
    local pem_pub="$pem.pub"

    local temp_dir="/tmp"
    local datetime=$(date +'%Y-%m-%d')
    temp_dir="$temp_dir/ed25519_$datetime"
    mkdir_p "$temp_dir"
    local temp_pem="$temp_dir/ed25519.pem"
    local temp_pem_pub="$temp_pem.pub"

    exec_command "ssh-keygen -t ed25519 -a \"$key_length\" -f \"$temp_pem\" -C \"$comment\" -N \"\"" "false"
    exec_command "chmod 600 \"$temp_pem\""
    exec_command "chmod 600 \"$temp_pem_pub\""

    move_file "$temp_pem" "$pem"
    move_file "$temp_pem_pub" "$pem_pub"
    array_unique_push "EXIT_WITH_COMMANDS" "rm -r \"$temp_dir\""

    local rsa_equivalent=""
    case "$key_length" in
    64)
        rsa_equivalent="1024"
        ;;
    128)
        rsa_equivalent="2048"
        ;;
    256)
        rsa_equivalent="4096"
        ;;
    512)
        rsa_equivalent="8192"
        ;;
    *)
        rsa_equivalent="unknown-"
        return 1
        ;;
    esac

    log_message "âœ… ed25519 key files were successfully generated."
    log_message "ðŸ”‘ ed25519 key length: ${key_length}bit (RSA Equivalent: ${rsa_equivalent}bit)"
    log_message "ðŸ”‘ Private key file: $pem"
    log_message "ðŸ”‘ Public  key file: $pem_pub"
    log_message "ðŸ“ ed25519 key comment: $comment"
}

# Usage information
usage() {
    local current_file_path=$(current_file)
    log_message "Usage: $(basename "$current_file_path") connect <host_name>"
    log_message "       $(basename "$current_file_path") set-hostname <host_name>"
    log_message "       $(basename "$current_file_path") ls [specified_folder]"
    log_message "       $(basename "$current_file_path") create <specified_host>"
    log_message "       $(basename "$current_file_path") edit <specified_host>"
    log_message "       $(basename "$current_file_path") rm <specified_host>"
    log_message "       $(basename "$current_file_path") rsync 'local:/path/to/source' '<host_name>:/path/to/destination'"
    log_message "       $(basename "$current_file_path") rsync '<host_name>:/path/to/source' 'local:/path/to/destination'"
    log_message "       $(basename "$current_file_path") remote-command <host_name> <remote_command>"
    log_message "       $(basename "$current_file_path") genkey [specified_file_path] [comment] [strength=low|moderate|*high|extreme]"
    exit 1
}

# Main function to collect parameters and invoke SSH/MOSH handler
main() {
    local action=$(trim "$1")
    local param2=$(trim "$2")
    local param3=$(trim "$3")

    # Parameters (these can come from the environment or command-line arguments)
    USE_PROXY="${USE_PROXY:-false}"
    USE_MOSH="${USE_MOSH:-false}"
    USERNAME="${USERNAME:-user}"
    HOST_ADDR="${HOST_ADDR:-}"
    HOST_PORT="${HOST_PORT:-22}"
    MOSH_PORTS="${MOSH_PORTS:-60000:61000}"
    PROXY_ADDR="${PROXY_ADDR:-}"
    PROXY_PORT="${PROXY_PORT:-8080}"
    PREFER_PEM="${PREFER_PEM:-true}"
    PEM_FILE="${PEM_FILE:-}"

    mkdir_p "$HOSTS_INFO_DIR" || {
        error_exit "Failed to mkdir: \"$HOSTS_INFO_DIR\""
    }

    case "$action" in
    "connect")
        # Call the SSH/MOSH handler with the parameters
        set_host_info "$param2"
        ssh_handle "connect"
        ;;
    "set-hostname")
        # Call the SSH/MOSH handler with the parameters
        set_host_info "$param2"
        ssh_handle "set-hostname"
        ;;
    "ls")
        # Call the SSH/MOSH handler with the parameters
        list_hosts "$param2"
        ;;
    "create")
        # Call the SSH/MOSH handler with the parameters
        create "$param2"
        ;;
    "edit")
        # Call the SSH/MOSH handler with the parameters
        edit "$param2"
        ;;
    "rm")
        # Call the SSH/MOSH handler with the parameters
        remove "$param2" "$param3"
        ;;
    "rsync")
        # Call the SSH/MOSH handler with the parameters
        ssh_handle "rsync" "$param2" "$param3"
        ;;
    "remote-command")
        # Call the SSH/MOSH handler with the parameters
        set_host_info "$param2"
        ssh_handle "remote-command" "$param2" "$param3"
        ;;
    "genkey")
        # Generate a pair of regular ed25519 keys
        gen_ed25519_key "$param2" "$param3"
        ;;
    "install")
        # Installation
        confirm_to_install
        ;;
    *)
        usage
        ;;
    esac
}

# Execute the main function
main "$@"
